‚úÖ Principios SOLID (Explicados)
1. Single Responsibility Principle (SRP)

Una clase debe tener una √∫nica raz√≥n para cambiar.

Significa que cada clase o m√≥dulo debe enfocarse en una sola cosa o responsabilidad.

Si una clase tiene m√∫ltiples responsabilidades, cualquier cambio en una de ellas podr√≠a afectar las otras, haciendo que el c√≥digo sea m√°s dif√≠cil de mantener y m√°s propenso a errores.

Ejemplo: En lugar de tener una clase Empleado que maneje tanto datos personales como c√°lculo de n√≥mina, es mejor separar esas responsabilidades en clases diferentes.

2. Open/Closed Principle (OCP)

El software debe estar abierto para extensi√≥n, pero cerrado para modificaci√≥n.

Esto quiere decir que puedes agregar funcionalidades nuevas sin alterar el c√≥digo existente, para evitar introducir bugs.

Normalmente se logra usando abstracciones como interfaces o clases base y extendiendo esas clases para agregar nuevas funcionalidades.

Ejemplo: Un sistema de pagos puede tener una clase base Pago y distintas subclases como PagoConTarjeta, PagoConPayPal, etc., que puedes agregar sin modificar la clase base.

3. Liskov Substitution Principle (LSP)

Los objetos de una clase derivada deben poder sustituir a objetos de la clase base sin alterar el correcto funcionamiento del programa.

La subclase debe respetar el comportamiento esperado de la clase base, sin introducir efectos secundarios inesperados.

Si un cliente espera un objeto del tipo base, puede usar sin problema un objeto de la subclase.

Ejemplo: Si tienes una clase Ave y una subclase Pato, todas las funciones que usan Ave deber√≠an poder funcionar correctamente con un Pato.

4. Interface Segregation Principle (ISP)

Los clientes no deben estar forzados a depender de interfaces que no usan.

Es mejor dividir interfaces grandes y generales en interfaces m√°s peque√±as y espec√≠ficas para que las clases solo implementen lo que necesitan.

Evita que las clases se llenen de m√©todos que no utilizan, lo cual hace el c√≥digo m√°s limpio y entendible.

Ejemplo: En lugar de tener una interfaz Animal con m√©todos volar(), nadar(), caminar(), es mejor crear interfaces espec√≠ficas para cada tipo de comportamiento.

5. Dependency Inversion Principle (DIP)

Los m√≥dulos de alto nivel no deben depender de m√≥dulos de bajo nivel; ambos deben depender de abstracciones.

Las abstracciones no deben depender de los detalles, sino los detalles de las abstracciones.

Esto permite cambiar las implementaciones concretas sin afectar el c√≥digo que depende de esas abstracciones.

Ejemplo: En lugar de que una clase Controlador cree directamente un objeto Repositorio, deber√≠a depender de una interfaz IRepositorio y la implementaci√≥n concreta se inyecta (inyecci√≥n de dependencias).

üß© Otros 5 principios de dise√±o (Explicados)
1. DRY (Don‚Äôt Repeat Yourself)

Evita la duplicaci√≥n de c√≥digo o l√≥gica.

La duplicaci√≥n lleva a inconsistencias y hace dif√≠cil mantener el c√≥digo. Si algo cambia, debes actualizar todas las copias.

Centralizar el c√≥digo com√∫n en funciones, clases o m√≥dulos facilita su mantenimiento.

Ejemplo: Si tienes la l√≥gica de c√°lculo de impuestos en varios sitios, mejor ponerla en un solo m√©todo reutilizable.

2. YAGNI (You Aren‚Äôt Gonna Need It)

No implementes funcionalidades antes de que sean necesarias.

Muchas veces los desarrolladores agregan caracter√≠sticas ‚Äúpor si acaso‚Äù que nunca se usan, lo que complica el sistema y retrasa el desarrollo.

Se recomienda desarrollar solo lo que se requiere en el momento, ajustando el c√≥digo cuando sea necesario.

Ejemplo: No crear un sistema de reportes complejos si a√∫n no se han solicitado.

3. SoC (Separation of Concerns)

Separaci√≥n de responsabilidades o intereses.

Cada parte del sistema debe encargarse de una preocupaci√≥n espec√≠fica y estar desacoplada del resto.

Facilita entender, modificar y escalar el sistema, porque los cambios en una preocupaci√≥n no afectan a otras.

Ejemplo: En una aplicaci√≥n web, separar la l√≥gica de presentaci√≥n, la l√≥gica de negocio y el acceso a datos en capas diferentes.

4. Tell, Don‚Äôt Ask

Dile a los objetos qu√© hacer, no les preguntes por su estado para decidir qu√© hacer.

En lugar de consultar atributos o estados y tomar decisiones fuera del objeto, se delega el comportamiento al propio objeto.

Esto mejora la encapsulaci√≥n y hace el c√≥digo m√°s orientado a objetos y menos procedural.

Ejemplo: En lugar de preguntar si un Pedido est√° listo y luego procesarlo, simplemente llamas a pedido.procesar() y el objeto sabe c√≥mo hacerlo.

5. Composition Over Inheritance

Prefiere la composici√≥n (usar objetos dentro de otros) en lugar de la herencia para reutilizar c√≥digo.

La composici√≥n es m√°s flexible y evita problemas como la herencia m√∫ltiple o jerarqu√≠as complejas.

Permite cambiar el comportamiento de los objetos en tiempo de ejecuci√≥n y mejora la reutilizaci√≥n.

Ejemplo: En lugar de que Coche herede de Motor, el Coche puede tener un objeto Motor para delegar su funcionamiento.
